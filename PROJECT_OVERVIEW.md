Great. I’ll generate an updated and comprehensive Project Overview and Architecture document for the `stackr` project. It will incorporate all the recent insights and requirements, including core features like the DCA engine, strategy evaluation, withdrawal automation, mobile UX with human-in-the-loop interaction, Docker containerization, and LangGraph integration.

I'll include all selected technologies with a focus on modular design patterns such as plugin, adapter, and strategy architectures. The output will include detailed architecture diagrams—system overview, data flow, component relationships—and a structured markdown overview.

I'll get started and let you know once the draft is ready for review.

# Stackr Project Overview and Architecture

## Project Overview

Stackr is a self-hosted **Bitcoin accumulation and automation application**. Its primary purpose is to help users **dollar-cost average (DCA) into Bitcoin** and **automate withdrawals** to self-custody, all while maintaining flexibility and user control. The high-level goals of Stackr include:

- **Automated Scheduled Buying:** Allow users to purchase Bitcoin on a regular schedule (e.g. daily, weekly) without manual intervention. This smooths out volatility by investing a fixed amount at set intervals (the essence of DCA).
- **Accumulation Strategies:** Support plugin-based strategies beyond simple DCA. While basic DCA is the default, the system is designed to accommodate various strategies (e.g. value averaging, dip-buying triggers) by using an extensible strategy engine.
- **Automated Withdrawals to Self-Custody:** After accumulation, automatically withdraw the Bitcoin to the user’s own wallet on a schedule or trigger basis. Stackr uses an **extended public key (xpub)** from the user’s wallet to generate a fresh deposit address for each withdrawal, preserving privacy by avoiding address reuse.
- **User Control and Transparency:** Keep the human in the loop. Users can configure strategies and withdrawal rules, receive notifications, and have the option to approve certain actions. The system favors automation **with** oversight rather than a black-box trading bot.
- **Ease of Deployment & Portability:** The entire application is containerized with **Docker** for easy deployment on various environments (cloud VM, home server, etc.). From the outset, the architecture is built to be lightweight (using SQLite for storage) and simple to run anywhere.

In summary, Stackr aims to provide a **personal “Bitcoin stacking” service**: it automates the tedious parts of buying and withdrawing Bitcoin while ensuring the user retains custody of funds and control over the process. The following sections describe the core components, design principles, and how they interact within the system.

## System Architecture

The Stackr system is composed of several modular components orchestrated together. At a high level, it includes:

- **DCA Engine** – handles scheduled Bitcoin purchases.
- **Strategy Engine** – plugin-based system to determine _how_ and _when_ to buy (DCA is one strategy).
- **Withdrawal Module** – automates transfers of accumulated Bitcoin to the user’s wallet (using new addresses from an xpub).
- **Bitcoin Core Integration** – a Bitcoin Core node (on testnet for development) provides blockchain interaction.
- **Orchestration Engine (LangGraph)** – coordinates the workflow of the above modules and manages user interaction points.
- **Data Persistence** – a lightweight SQLite database to store configuration, state, and logs.
- **Deployment Container** – Docker setup for running the Node.js app and Bitcoin Core node in isolation.
- **Human-in-the-Loop Interface** – a user interface (mobile-friendly) and notification system to involve the user when needed.

![Stackr System Architecture Diagram: High-level components and their interactions](data:image/png;base64,{{b64_images['stackr_arch.png']}})

_Figure: High-level System Architecture._ The Node.js application (Stackr core) contains the orchestration logic, DCA engine, strategy plugins, withdrawal module, and database. It interacts with external services: a Bitcoin Core **testnet** node (for blockchain operations) and a push notification service. The user interacts via a mobile-friendly interface, receiving alerts and providing input or approvals.

In this architecture, **LangGraph** (an orchestration library) plays a central role in managing complex flows. LangGraph allows building workflows as a directed graph of steps, with conditional branches, loops, and state management. Stackr leverages this to sequence operations like “On schedule -> execute buy -> if criteria met -> initiate withdrawal -> notify user”, and to insert decision points where human approval might be required. This graph-based orchestration makes the system **modular and extensible**, as each node in the workflow can be a self-contained task (e.g. “Execute buy order” or “Check withdrawal condition”) and new logic can be added as new nodes or branches.

The overall design follows **modular principles**: each component has a single responsibility, and communicates with others through well-defined interfaces. This makes it easier to maintain and extend the system (for example, adding a new exchange integration or a new strategy plugin won’t require rewriting the whole system).

## Core Components

### DCA Engine

The **Dollar-Cost Averaging (DCA) Engine** is responsible for executing recurring buy orders for Bitcoin. Users configure a schedule (e.g. every Monday at 10:00 or daily at midnight) and an amount or funding source for each purchase. The DCA engine ensures that at each scheduled interval, an order to buy Bitcoin is placed.

- **Scheduling:** The engine either uses a scheduling library (like cron jobs in Node or the LangGraph orchestrator’s timing nodes) to wake up on the defined intervals. It reads the user’s DCA settings (schedule, amount) from the database and triggers a buy order. This happens unattended, enabling “set-and-forget” investing.
- **Execution of Buy Orders:** The DCA engine doesn’t directly talk to an exchange in a hard-coded way. Instead, it calls an abstract **Exchange Adapter** interface (see Strategy Engine below for architecture) – this decoupling means the engine can work with any exchange integration provided by a plugin or adapter. For example, whether the app is using a **Bitcoin exchange API** (like Kraken, Binance, etc.) or a mock trading service on testnet, the DCA engine just invokes a generic `buy(amount)` operation on the adapter. This follows a _ports-and-adapters (hexagonal)_ style, isolating the core logic from external API specifics.
- **Error Handling and Alerts:** If a scheduled buy fails (e.g. exchange API down or insufficient funds), the engine can capture that error and, through the orchestrator, notify the user via a push notification. The user can then take action (e.g. top up funds or retry manually). This ensures transparency when automation encounters issues.
- **Logging:** Every buy order (successful or failed) is recorded in the SQLite database with a timestamp, amount, price, and transaction details. This audit trail lets the user review their purchase history and is useful for debugging and tracking performance over time.

The DCA Engine thus automates the repetitive task of buying. By abstracting exchange interactions through adapters and by running on a schedule, it provides hands-free accumulation while remaining flexible to different providers and conditions.

### Accumulation Strategy Engine (Plugin-Based Strategies)

While basic DCA (buying a fixed amount on a fixed schedule) is the default strategy, Stackr includes a **Strategy Engine** that supports plugin-based strategies. This is implemented using the **Strategy Pattern** – different accumulation algorithms can be encapsulated as interchangeable “strategy” classes – and an **Adapter Pattern** to interface with external data or exchanges.

- **Strategy Interface:** At the core, there is an `AccumulationStrategy` interface (or abstract class) defining the method (e.g. `getNextPurchase()` or `executeStrategy()`) that returns instructions for the next buy. The DCA strategy might simply return “buy X amount every interval,” whereas a more complex strategy could consider external factors (price dips, volatility, etc.).
- **Plugin Architecture:** New strategies can be added as **plugins**. For instance, one could drop in a “Moving Average Crossover” strategy plugin that buys more on dips, or a “Random DCA” that randomizes the buy time within a window. The system discovers and loads these strategy plugins (e.g. via a folder or config), allowing extensibility without modifying core code. This modular approach uses the strategy pattern at runtime – the user can select which strategy to use for their accumulation, and the system just calls the strategy’s interface methods.
- **Adapter for Exchanges:** The strategy engine (and DCA engine) do not directly depend on any one exchange’s API. Instead, Stackr defines an **Exchange Adapter** interface with methods such as `buy(amount)`, `getBalance()`, `withdraw(address, amount)`, etc. There can be multiple implementations: `KrakenAdapter`, `CoinbaseAdapter`, `BinanceAdapter`, etc., each translating the generic calls into the specific API calls for that exchange. At startup, the app can be configured to use a particular exchange; the corresponding adapter is loaded and used by the engines. This means adding support for a new exchange is as simple as writing a new adapter class that implements the interface, without changing the higher-level logic.
- **Decision Logic:** For simple DCA, the decision is trivial (always buy the same amount on schedule). For more advanced strategies, the Strategy Engine might query external data (price feeds, indicators) through services or APIs. These too can be abstracted via adapters or injected services, so that, for example, a strategy could use a price feed from CoinGecko or another source interchangeably. The LangGraph orchestrator can facilitate these calls as part of the workflow graph (e.g. a node that fetches the current price if the strategy needs it).
- **Integration with DCA Engine:** The DCA Engine uses whichever strategy is active to determine _what_ to do when a schedule triggers. Pseudocode: `strategy = getActiveStrategy(); buyParams = strategy.getNextPurchase(); exchangeAdapter.buy(buyParams.amount);`. The strategy could also signal “no action” (if, say, conditions aren’t met). In this way, DCA is just one strategy plugin; the system is not limited to fixed-interval purchases.

![Component Architecture – Strategy and Adapter Patterns](data:image/png;base64,{{b64_images['stackr_components.png']}})

_Figure: Core components and interfaces._ The DCA Engine uses an `AccumulationStrategy` (e.g. DCA Strategy, Value Averaging Strategy) and an `ExchangeAdapter` for the exchange API. The Withdrawal Module similarly uses the exchange adapter (for withdrawals) and an `AddressProvider` for deriving new addresses. This design allows swapping in different strategy algorithms and different exchange integrations without changing the core logic (following the Open/Closed principle). New strategies or adapters can be added as plugins that implement the respective interfaces.

By employing these design patterns, Stackr’s accumulation logic is **both flexible and future-proof**. New accumulation strategies or integration with new trading platforms can be achieved without refactoring the whole system – just plug in new modules. This modularity is a key architectural principle for Stackr.

### Withdrawal Automation Module

The **Withdrawal Automation Module** handles the **automatic transfer of accumulated Bitcoin to the user’s own wallet**. Its goal is to minimize the time funds stay on an exchange or custodial platform, thereby reducing counterparty risk, while also enforcing good privacy practices (using new addresses for each batch of coins). Key aspects of this module:

- **Scheduling & Triggers:** The withdrawal can be scheduled (e.g. withdraw once a week, or on the last day of the month after the final buy) and/or trigger-based (e.g. withdraw whenever the exchange balance exceeds a certain amount). These rules are configurable by the user. For example, a user might choose to buy daily but only withdraw monthly to save on fees. Another user might withdraw immediately after each buy for maximum self-custody. The module checks the conditions after each DCA cycle or on a separate schedule.
- **Xpub-Based Address Generation:** To protect privacy, **each withdrawal should go to a new Bitcoin address**. Stackr achieves this by having the user provide an **Extended Public Key (xpub)** from their wallet at setup. An xpub is a master public key from an HD wallet from which a sequence of public addresses can be derived. The Withdrawal module incorporates an `AddressProvider` (as shown in the component diagram) which uses the xpub to derive the next unused address for every withdrawal. This way, the user’s private keys remain offline (xpub is read-only), and Stackr can keep generating new addresses as needed. Using new addresses prevents linkability between deposits, preserving on-chain privacy (address reuse is _highly discouraged in Bitcoin_).
- **Address Tracking:** One challenge with using an xpub is knowing which addresses have been used already (to always pick a fresh one). Stackr takes two possible approaches here:

  - _Simplified approach:_ assume the xpub provided is dedicated for Stackr withdrawals (a fresh account in the user’s wallet). The module maintains an internal counter of the last index used. Each time a new address is needed, it increments the index and derives the address. Since no other application is using that xpub, any new index is guaranteed unused. This is the approach recommended by similar tools for simplicity and trustlessness (no outside dependency).
  - _Node-assisted approach:_ integrate with the Bitcoin Core node to check address usage. In this approach, the user’s xpub could be imported into the Bitcoin Core testnet node as a watch-only wallet. The module can then ask the node for a new unused address or query whether an address has been seen on-chain. Bitcoin Core (with proper wallet import or output descriptors) can track which addresses are used and automatically give out the next unused address. This approach leverages the **Bitcoin Core integration** to provide more assurance that an address is truly unused (especially useful if the xpub is not exclusive to Stackr). The trade-off is added complexity and the need to trust the node’s state. Since Stackr is already running a Bitcoin Core instance, using it for address management is viable. (In the initial implementation, the simpler internal-counter method might be used, deferring a more advanced index check until needed.)

- **Executing Withdrawals:** Once an address is obtained, the module triggers the actual withdrawal of funds. If using an exchange API, it will call the exchange’s withdrawal endpoint via the Exchange Adapter (e.g. `exchangeAdapter.withdraw(address, amount)`). Many exchanges require specifying an amount and possibly a withdrawal fee or use a preset fee. The module may withdraw either the entire available balance or a user-specified amount (some might choose to leave a small balance to avoid dust, etc., which could be a configuration).
- **Bitcoin Core (testnet) integration:** In a development/test mode, or if Stackr were to operate without a third-party exchange, the module could create and broadcast a transaction via the connected Bitcoin Core node. For example, if Stackr held funds in a wallet (like a hot wallet scenario), it could construct a transaction sending to the xpub-derived address and use the node to broadcast it. However, in typical use (with an exchange handling custody until withdrawal), the node is likely just observing. On testnet, Stackr can simulate an exchange by using a Bitcoin Core wallet as the source of funds for withdrawals (this allows end-to-end testing of the withdrawal logic on testnet coins).
- **Confirmation and Logging:** After requesting a withdrawal, the module logs the event (address, amount, transaction ID, timestamp) in the SQLite DB. It then monitors for confirmation. If integrated with Bitcoin Core, it can poll the node or listen for the transaction confirmation (especially on testnet, where it can subscribe to ZMQ or use RPC to check tx status). Once the withdrawal is confirmed on-chain, the system can send a final notification to the user. All this information is recorded for the user’s reference.
- **Security Considerations:** The module ensures that the xpub is stored securely (it’s not secret like a private key, but it reveals all future addresses, so it’s handled with care). It also makes sure not to leak xpub or addresses to external services unnecessarily. Withdrawals are only sent to derived addresses, never an address not under the user’s control. The user’s exchange API keys used for withdrawal are also stored securely (and ideally scoped only to trading and withdrawal on the exchange side for safety).

By automating withdrawals, Stackr enforces a **best practice: “Not your keys, not your coins.”** It minimizes custodial risk by sweeping funds to the user’s wallet on a regular basis. The use of xpub and fresh addresses aligns with privacy best practices in Bitcoin, ensuring the user’s accumulating wealth isn’t all tied to a single address that could be tracked.

### Bitcoin Core Testnet Integration

Stackr integrates a **Bitcoin Core** node on **testnet** as part of its architecture. There are several reasons and functions for this integration:

- **Development and Testing:** Running on testnet (Bitcoin’s public testing blockchain) allows Stackr to simulate the entire buy-withdraw cycle without real money. The testnet node provides a realistic environment where transactions can be created and confirmed, addresses can be generated, and Bitcoin network behavior observed – all without risking real funds. Developers and users testing Stackr can use testnet coins (which have no monetary value) to ensure the system works end-to-end.
- **Address Derivation and Tracking:** As mentioned in the Withdrawal module, the Bitcoin Core node can be used to manage the xpub for withdrawals. By importing the xpub into the node as a watch-only wallet (or using output descriptors), Stackr can delegate address derivation to Bitcoin Core’s wallet. Bitcoin Core will ensure addresses follow the BIP32/BIP84 path and can check if they’ve been used. For example, the application can call `getnewaddress "" "walletname"` on a watch-only wallet based on the xpub, and Bitcoin Core will return the next unused testnet address. It can also track received transactions to those addresses.
- **Monitoring Transactions:** The node can be used to monitor that withdrawals have been executed correctly. Once a withdrawal is initiated (either by the exchange or simulated by the app), the Bitcoin Core node (which is connected to the testnet network) can be queried for the transaction status (confirmations, etc.). This provides an independent verification of the withdrawal beyond trusting the exchange’s API response. In mainnet usage, a Bitcoin node integration would be valuable for trust-minimized confirmation checking.
- **Potential Future On-Chain Transactions:** In future extensions, Stackr might support buying via other means not through an exchange (for instance, via decentralized marketplaces or via the node itself using some script or the Lightning Network). The presence of a Bitcoin Core instance opens up possibilities: the app could construct transactions or use the node’s wallet to manage funds if needed. For now, the primary use is testnet operations and support tasks (address tracking, monitoring).
- **Isolation and Security:** The Bitcoin Core node runs in a Docker container separate from the main app. This isolation means that heavy blockchain operations (downloading blocks, verifying transactions) do not interfere with the responsiveness of the Stackr application. The Node.js app communicates with Bitcoin Core via RPC calls (e.g. using `bitcoin-cli` or a JSON-RPC library pointed at the node). RPC credentials are managed via environment variables or config in Docker, and only the Stackr app has access. The node is configured for testnet (network parameters and separate data directory).
- **Resource Considerations:** Bitcoin testnet still requires downloading and processing the blockchain (which can be several GBs). Since Stackr is Dockerized, users can optionally enable or disable the bundled Bitcoin Core node. In development, one might run the node to get full functionality. In production (on mainnet), an advanced user might point Stackr to an external Bitcoin node or use a light client, depending on resources. The architecture is flexible to allow this (the “Bitcoin Core integration” could be abstracted behind an interface as well, to allow swapping between a full node, an electrum server, or an API). Initially, though, the focus is on using a full node for robustness and privacy.

Overall, including a Bitcoin Core testnet node demonstrates Stackr’s philosophy of being a **self-contained, sovereign tool**. It doesn’t have to rely on third-party blockchain explorers or services to know what’s happening on-chain – it can verify using its own node. This aligns with Bitcoin’s trust-minimized ethos (don’t trust, verify). For the user, it means greater privacy (your addresses are checked by your own node) and independence.

### LangGraph Orchestration (User Flow & Automation)

**LangGraph** is the orchestration engine used within Stackr to manage user flows and automation logic. LangGraph (a library built on top of LangChain) allows the definition of workflows as graphs of nodes and edges, which is ideal for encoding the **business logic and decision tree** of the Stackr application.

In Stackr, LangGraph is used to coordinate multi-step processes and incorporate conditional logic or loops in a clean way:

- **Defining the Workflow:** The series of actions for a typical cycle – e.g., “wait for schedule -> perform buy -> record result -> check if withdrawal needed -> if yes, perform withdrawal -> notify user” – can be represented as a graph. Each step is a **node** in LangGraph, and edges determine the order or conditional branching. For example, after a buy, one edge might always lead to logging, but a conditional edge might go to the withdrawal step only if the withdrawal criteria are met (like time since last withdraw or balance threshold).
- **Parallel and Conditional Logic:** LangGraph makes it easier to handle more complex logic than a simple linear script. For instance, if multiple conditions could trigger different actions (maybe one strategy has two possible paths: if price is above X do one thing, else do another), this can be modeled as branching nodes. Loops can also be implemented – although most of Stackr’s flows are cyclical in the sense of repeating on schedule rather than infinite loops. (LangGraph’s support for loops and cycles could be used for continuously monitoring conditions or implementing a retry mechanism – e.g., if a buy fails, loop back to try again or alert and pause.)
- **Maintaining State:** LangGraph allows passing a state object through the workflow, where each node can read or modify the state. Stackr uses this to carry information like the user’s settings, current prices, order results, etc., from one step to the next in the flow. For example, after a “Get current price” node, the price can be stored in state and used by the “Decide buy amount” node.
- **Integration with LLMs (Future Potential):** Notably, LangGraph is designed with LLM (Large Language Model) agents in mind. While Stackr’s core doesn’t inherently require AI, the inclusion of LangGraph opens the door to interesting features. For instance, a future version of Stackr might include a conversational assistant that can understand commands like “increase my weekly buy amount if the price drops 10%” – an LLM could interpret this and adjust settings or create a one-off additional buy if conditions are met. LangGraph could orchestrate such an agent: one node uses an LLM to parse user instructions or analyze market context, and subsequent nodes execute the actions. This is speculative, but the architecture is ready for it. At minimum, LangGraph’s robust orchestration capabilities are used for non-AI logic, but the possibility of adding an AI agent for advanced user interaction or smart decision-making is an exciting future extension.
- **Human-in-the-Loop Nodes:** A key advantage of modeling flows in LangGraph is that you can insert **manual approval steps** as needed. For example, even if the user has an auto-withdraw rule, one might add a step: “Send notification to user and wait for approval if withdrawal amount > X”. This would pause the workflow until the user confirms (perhaps via the mobile app or clicking a link). If approved, the flow continues to execute the withdrawal; if not, it could branch to skip it. LangGraph can handle waiting and resuming flows. This ensures Stackr can implement governance rules like requiring user confirmation for large transactions or any action the user flags as needing explicit consent.
- **Reusable Modular Tasks:** Each major function (buying, withdrawing, notifying) can be a reusable node in the graph. The benefit is if the user triggers an on-demand action (say the user presses “withdraw now” manually in the UI), the orchestrator can reuse the same “withdrawal process” node sequence outside of the scheduled flow. This avoids code duplication – the logic lives in the LangGraph definition and can be invoked by different triggers (schedule vs. manual).
- **Error Handling and Recovery:** With LangGraph, it’s possible to model error paths. For example, a node that interacts with the exchange API might branch to a different node if an error occurs (like a node that composes an error message and triggers a notification, or a node that increments a retry counter and loops back to try again after some delay). This makes the automation more resilient.

In summary, LangGraph provides a **structured way to orchestrate Stackr’s operations**. Instead of writing a bunch of ad-hoc asynchronous callbacks or promise chains, the team defines a clear workflow graph. This improves readability and maintainability of the automation logic. The system becomes a set of interconnected **state machines** that can even handle complex scenarios with ease. The result is an automation engine that is both powerful and adaptable, giving Stackr a solid foundation to build advanced features (and even incorporate AI-driven logic) in the future.

### Data Persistence (SQLite Database)

All of Stackr’s runtime data and configuration is stored in a **SQLite database** file. SQLite was chosen for its simplicity and zero-configuration setup, which fits with the Stackr goal of being easy to deploy and run anywhere:

- **Configuration Storage:** User settings such as DCA schedule, DCA amount, selected strategy, exchange API credentials, withdrawal rules (frequency, threshold), and the user’s xpub are stored in the database (likely in a configuration table). This allows the application to load settings on startup and the user to modify settings via the UI which then get persisted.
- **State Tracking:** The database keeps track of stateful information like:

  - The last index used for deriving an address from the xpub (if using internal tracking).
  - Timestamp of the last successful withdrawal (for interval calculations).
  - Current balance on the exchange (if polled or updated via API).
  - Any paused status (e.g., if the user temporarily pauses automation, that flag is stored).

- **Logs and Records:** Each executed action gets logged. Tables for buy orders, withdrawal transactions, errors, and notifications ensure there’s a historical record. For example, a `purchases` table might have columns: id, date, amount_fiat, amount_btc, price, exchange_order_id, status. A `withdrawals` table might have: id, date, amount_btc, address, txid, status (pending/confirmed). This audit trail is useful for the user (to review what happened when) and for debugging. It can also feed a simple reporting interface (e.g., total BTC accumulated over time).
- **Lightweight and Embedded:** SQLite runs in-process with Node.js, requiring no separate service. This is ideal for a Dockerized app – one less service to maintain. Performance-wise, SQLite can easily handle the modest load of a single-user automation tool (few writes per scheduled event, minimal concurrency issues).
- **Backup and Portability:** The entire database resides in a single file (e.g., `stackr.db`). Users can backup this file to save their history and state. If migrating the app to another server or upgrading, one can move the DB file. Also, because it’s a standard SQLite, advanced users could open it with DB browsers or run queries if needed (for example, to audit their data or integrate with other tools).
- **Future Expansion:** If the project grows in scope (e.g. multi-user or heavier data needs), the persistence layer could be swapped out for a stronger database (PostgreSQL, etc.). The code accessing the database can be abstracted (using an ORM or data access module) such that switching the backend is feasible. But for now, SQLite provides an excellent trade-off of simplicity and functionality.

In essence, the SQLite DB is the **single source of truth** for Stackr’s operations aside from external systems. It ensures that even if the app restarts, it remembers where it left off (e.g., which address index to use next, or that a withdrawal is pending confirmation). This persistence is crucial for reliable automation.

### Human-in-the-Loop Interface (Mobile UX & Notifications)

Stackr is designed to be automated **but not completely hands-off** – the user remains an integral part of the control loop. To facilitate this, Stackr provides a **human-in-the-loop interface** focusing on a mobile experience and push notifications:

- **Mobile-Friendly Dashboard:** The user interface (UI) for Stackr is optimized for mobile devices, given that users want to casually monitor or tweak their Bitcoin stacking on the go. This could be implemented as a simple web dashboard with responsive design or even as a dedicated mobile app in the future. Key information shown includes current accumulated BTC, next scheduled buy time, next withdrawal time, recent activity logs, and any alerts that need user attention.
- **Settings and Manual Control:** Through the interface, the user can adjust settings (schedule, amounts, strategy selection, etc.), turn automation on/off, or manually trigger actions. For example, if the user hits “Pause DCA”, the system will skip scheduled buys until reactivated. If the user hits “Withdraw now”, the orchestrator will jump to execute the withdrawal workflow immediately. These controls allow the human operator to override or fine-tune the automation when needed.
- **Push Notifications:** Stackr integrates with a push notification service (such as Firebase Cloud Messaging or a similar service) to send real-time alerts to the user’s mobile device. Notifications are used for important events, for example:

  - Confirmation of a purchase (e.g., “Bought 0.001 BTC at \$30,000 on 2025-07-01”).
  - Alert before a large withdrawal (perhaps giving the user a chance to cancel if unexpected).
  - Confirmation of withdrawal initiated (with txid and link to a block explorer, if mainnet).
  - Errors or issues (e.g., “Buy failed: insufficient funds in exchange account”, or “Exchange API key expired”).
    These push notifications keep the user informed without needing to constantly check the app. They are a key part of maintaining user trust in the automation – the user is always in the loop about what’s happening.

- **Approval Workflow:** As touched on earlier, certain actions can be configured to require user approval. The interface would surface an actionable alert or prompt. For instance, a notification might say: “Scheduled withdrawal of 0.05 BTC ready to send to address bc1xyz... Swipe to approve.” The user could then approve or reject through the app. If approved, the flow continues; if rejected, Stackr might skip that withdrawal and reschedule or ask again later. This mechanism is especially useful for larger transactions or any time the user just wants that extra confirmation step.
- **Security and Authentication:** The UI is protected (login or at least a PIN, since it deals with sensitive info and controlling money flows). If it’s a web UI, it will likely run on the local network or behind a secure tunnel, given that Stackr is self-hosted. Access could be via a VPN or secure web connection to the user’s host. For a mobile app, standard authentication and perhaps biometrics could be used to ensure only the authorized person receives and responds to these actions.
- **User Experience Considerations:** The design emphasizes clarity – since this deals with financial transactions, the user should easily see what the system is doing and planning to do. Graphs or summaries might be included (e.g., a chart of BTC accumulated over time, or a forecast of next month’s total based on settings). However, initially, the focus is on reliability and transparency rather than flashy UI. A straightforward list of recent events and upcoming events might suffice.
- **Notifications Configuration:** Users can tailor what they get notified about. Some might want notifications for every single buy and withdraw; others might only want to be alerted on failures or when manual action is needed. Stackr would allow toggling these preferences.
- **Human Override:** In case the user needs to immediately stop all actions (for example, something seems wrong, or markets are crashing and the user wants to deviate from the plan), there is a **big red “Stop” button** (or equivalent). This could disable all automation until re-enabled. It’s a safety hatch that ensures the human operator can always take back full manual control instantly.

By emphasizing a human-friendly interface and notifications, Stackr differentiates itself from a “set it and forget it” bot. The user remains aware and in control, which is crucial for trust. Automation is great for removing repetitive tasks, but when real money is involved, users often want the reassurance that they’ll be alerted and can intervene if needed. Stackr’s UX is built with this balance in mind.

### Dockerized Deployment Environment

From day one, Stackr is built to run inside **Docker containers** for ease of deployment and consistency across environments. The project provides a Docker setup that encapsulates the application and its dependencies. The main elements include:

- **Node.js Application Container:** The core Stackr app (written in Node.js) runs in a container. This container includes the Node runtime, the application code, and all necessary libraries (LangGraph, SQLite, etc.). By containerizing it, we eliminate the “it works on my machine” problem – everyone running Stackr uses the same environment. The Dockerfile likely starts from an official Node image, copies the Stackr code, installs dependencies, and sets up the entrypoint (e.g., `npm start`).
- **Bitcoin Core Container:** Another container runs Bitcoin Core in testnet mode. This might use the official `bitcoin-core` image or a custom build configured for testnet. It exposes RPC on a certain port (only accessible by the Stackr app container for security). The node container will volume-map its data directory to the host (to persist the blockchain between restarts). The Docker Compose configuration will ensure the Bitcoin node is up and running, and possibly wait for it to be ready before the Stackr app starts.
- **Network and Connectivity:** Docker Compose (or a similar tool) is used to define the multi-container setup. The Stackr app container and Bitcoin container are joined in a common Docker network so they can communicate. For example, the Stackr app might reach the Bitcoin node via hostname `bitcoin-node` on the Docker network. Any necessary environment variables (like Bitcoin RPC username/password, or exchange API keys) can be passed via a `.env` file to Docker Compose to inject into the containers.
- **Push Notification Service Integration:** The push notification service is an external cloud service (not something we run in Docker). However, the credentials or API keys for it (if any) would be provided to the app container via environment variables. For instance, if using Firebase Cloud Messaging, the service account key or API token would be configured so the app can call FCM APIs to send messages. This keeps secrets out of the code and in environment config.
- **Volume for Data:** The SQLite database file should be stored on a Docker volume (or bind mount to host) so that data is persisted across container restarts. The same goes for any important files (logs, etc. – though logs could also be aggregated by Docker).
- **One-Step Setup:** The user should be able to launch the whole stack with a single command (e.g., `docker compose up -d`). This makes running Stackr on a fresh machine trivial – all dependencies (Node, Bitcoin Core, etc.) are handled by Docker. It also simplifies updates: pulling a new image version and restarting can update the app seamlessly.
- **Isolation and Security:** Docker adds a layer of isolation. The Bitcoin node is sandboxed from the system (only exposing required ports). The Node app container only has the privileges it needs. This reduces risks; for example, even if an attacker somehow exploits the Node app, they are in a container, limiting potential damage (and they still wouldn’t have the user’s keys since the keys are external in the user’s wallet).
- **DevOps and CI/CD:** With Docker, the same images used in development can be used in production. The project likely includes CI steps to build and maybe push Docker images. In a team setting, this ensures everyone tests under the same conditions. For deployment, a small server (could be a VPS or even a Raspberry Pi 4 for a single user at home) can run Docker and host Stackr. Monitoring and management of the container can be done with existing Docker tools.
- **Deployment Topology:** In many cases, Stackr will be deployed as two containers on a single host (the user’s server or machine). However, Docker allows flexibility: one could also run the Bitcoin node on a different host or use a remote node by adjusting config. But the default is to keep them together for simplicity. Everything is on testnet by default to prevent accidental real-money operations until the user intentionally switches to mainnet (which would require pointing to a mainnet node and using mainnet APIs).
- **Scaling and Multi-User (Future):** If Stackr ever evolved into a service for multiple users (e.g., a SaaS or a family running multiple accounts), the Dockerized approach could scale by running multiple instances or converting to a microservices architecture. For now, though, the focus is single-user personal deployment, which Docker suits perfectly.

![Deployment and DevOps Diagram: Containerized stack](data:image/png;base64,{{b64_images['stackr_deploy_v2.png']}})

_Figure: Deployment architecture._ Stackr runs as a set of Docker containers on a host machine. The **Stackr Node.js App** container houses the core application (DCA engine, strategy modules, etc.), while the **Bitcoin Core (testnet)** container runs alongside it, providing blockchain connectivity. The Node app communicates with Bitcoin Core via RPC calls over the Docker internal network. The user interacts with Stackr through a mobile or web UI (connecting to the Node app’s API) and receives push notifications via an external push service (e.g. Firebase). This containerized setup ensures easy and consistent deployment across environments.

Using Docker from the start ensures that anyone can get Stackr up and running quickly and that the environment is consistent for all users and developers. It encapsulates the complexity of running a Bitcoin node and the application logic into a reproducible package, paving the way for smoother updates and upgrades.

## Technologies Used

Stackr’s implementation leverages a variety of technologies and libraries, chosen to meet the requirements of reliability, flexibility, and ease of development:

- **Node.js (JavaScript/TypeScript)** – The primary language and runtime for the Stackr application. Node was chosen for its robust ecosystem (especially for web services and bots) and the ability to use LangGraph (which is built for Node) for orchestration. Async capabilities of Node handle scheduling and API calls easily.
- **LangGraph.js** – An orchestration and workflow library that extends LangChain’s capabilities. It allows the definition of the Stackr automation logic as a graph of steps and makes it easier to integrate any future AI components. LangGraph provides the backbone for the user flow management, conditional logic, and potentially the incorporation of LLM-driven decisions.
- **SQLite** – A lightweight SQL database used for storing Stackr’s data. SQLite’s zero-config, file-based nature makes it ideal for embedding in an application like this. It handles the moderate data needs without requiring a client-server DB setup.
- **Bitcoin Core** – The reference Bitcoin full node software, used here in testnet mode. It provides a trustworthy way to interact with the Bitcoin blockchain, generate addresses, and verify transactions. By using Bitcoin Core, Stackr benefits from Bitcoin’s strongest security model (full validation).
- **Docker** – Containerization platform to deploy the entire stack. Both the Node app and Bitcoin Core run in Docker containers, orchestrated by Docker Compose for easy management. This ensures that if it runs on one machine, it will run the same everywhere else.
- **Exchange APIs** – While not a single technology, Stackr will interact with one or more exchange APIs (or broker services) to execute buys and withdrawals. For example, Kraken’s REST API or Binance’s API might be used via HTTPS calls. The specific integration is abstracted via adapters, but behind the scenes uses standard web protocols.
- **Push Notifications Services** – e.g., Firebase Cloud Messaging (FCM) or Apple/Google push services if a native app. These services deliver the real-time notifications to the user’s device. The Stackr app would use the service’s SDK or HTTP calls to trigger notifications.
- **Mobile/Web Frontend** – Likely a minimal frontend built with a web framework (could be something like React or just server-side rendered pages from Node, or even a simple text-based interface via a messaging app). The exact tech here is open – it could be a small Express.js app serving pages, or a separate static frontend hitting Stackr’s API. Since the user specifically mentioned mobile UX, using a modern web frontend framework or a React Native/Ionic app could be considered down the line.
- **Encryption and Key Management** – While not explicitly listed, it’s worth noting: any sensitive data (API keys for exchanges, etc.) is handled carefully. Environment variables or a config file provide these to the app. If persisted (in SQLite), they might be encrypted. Node libraries like `dotenv` manage env vars, and crypto libraries could encrypt secrets if needed. Passwords or API keys are not logged or exposed.
- **Testing Frameworks** – During development, likely using Jest or Mocha for unit tests in Node, and perhaps some integration tests that simulate the workflows. This ensures that strategies and withdrawal logic work as expected under various scenarios (which is critical given financial stakes).
- **GitHub (or similar)** – For version control and collaboration (assuming this is an open-source or team project). CI/CD pipeline might be set up to run tests and build Docker images on commits.

Combining these technologies, Stackr stands on a modern, proven foundation. Node.js and Docker ensure cross-platform compatibility; LangGraph provides cutting-edge orchestration capability; Bitcoin Core ensures we follow Bitcoin best practices; and using simple tools like SQLite keeps the system approachable. Each component technology has a specific role, contributing to an overall system that is **cohesive yet modular**.

## Modular Design and Extensibility

One of the driving principles in Stackr’s architecture is **modularity** – the system is composed of interchangeable parts connected by clear interfaces. This makes the design **extensible** and adaptable for future needs:

- **Plugin Systems:** Both the strategy engine and exchange integration use plugin-like architectures. New strategies or new exchanges can be added with minimal changes to existing code. For example, if a new exchange API comes along, a developer can write a new adapter class for it, and Stackr can start using it by configuration – no need to rewrite the DCA logic. This follows the Open/Closed principle (open for extension, closed for modification) ensuring the core system doesn’t need alteration for new features.
- **Adapter/Strategy Patterns:** As illustrated earlier, these design patterns decouple the _what_ from the _how_. The strategy pattern lets us change _what logic_ decides the buy parameters, and the adapter pattern lets us change _how the buy is executed_ (which service or method). This separation of concerns means each part can evolve independently. Perhaps in the future, strategies could become quite sophisticated (even AI-driven) without needing to touch the stable exchange interface code. Or, the app could integrate with a Lightning Network service for buying instantly, by adding a Lightning adapter, while the rest of the system remains unchanged.
- **Hexagonal Architecture (Ports and Adapters):** The overall design follows a hexagonal or clean architecture approach, where the core domain (the scheduling, strategy, withdrawal logic) is at the center, and it interacts with the outside world through interfaces (ports). Adapters implement those ports for specific technologies (exchange APIs, databases, notification services). For instance, the DCA engine doesn’t know if it’s talking to Binance or Kraken; it just calls the “exchange port”. Similarly, if in the future one wanted to use a different database or an external data source for something, it could be made an adapter on a port.
- **Configuration-Driven Behavior:** Many aspects of Stackr can be configured, which adds flexibility without new code. The schedule, thresholds, active strategy, exchange selection, etc., are all driven by user configuration. This means the same codebase can serve different use cases (one user might run pure DCA on Exchange A, another might run a custom strategy on Exchange B – both are supported just by config). It also makes testing easier: you can simulate different scenarios by toggling config.
- **API and Extensions:** Although Stackr is primarily a self-contained app, the architecture anticipates **future API support**. For example, one could imagine a REST API or CLI where advanced users or other services can query Stackr (to get status or history) or even instruct it (e.g., an API call to execute a buy now, or to change a parameter). Because the internal logic is well-modularized, exposing an external API is straightforward – it would essentially call into the same functions that the UI or scheduler do. This opens up possibilities: integrations with other systems (maybe a Home Automation system triggers a buy when your salary comes in, via API, as a whimsical example).
- **Multi-Strategy or Multi-User Scaling:** In the future, if multiple strategies run concurrently (say one portion of funds on DCA, another portion on a different strategy), the design can handle it by spinning up multiple strategy instances or graph branches. The modular design is not hard-coded to a single strategy – conceptually, it could be extended to manage “portfolios” each with its own strategy. Likewise, while currently targeted at a single user, a lot of the design (with clear separation of concerns) would facilitate expanding to multi-user: e.g., separate DB tables per user, separate workflow instances per user, etc., all within the same app. This isn’t in scope now, but it’s good that the architecture wouldn’t fundamentally block it.
- **Testing and Maintenance:** Modular components are easier to test in isolation. Each adapter or plugin can have its own test suite (often using mocks for the external service). The orchestrator flows can be integration-tested by simulating time and events. This maintainability is a benefit of the chosen patterns. Future developers (or open-source contributors) can understand one piece of the system without needing full context of everything, because the interface contracts are clear.

The result is an architecture that is **robust yet flexible**. It’s robust in that each component is relatively simple and focused, and flexible in that components can be added or replaced. Stackr’s design anticipates change – whether that’s new market conditions requiring new strategies, new platforms to integrate with, or new features like AI guidance. This foresight in design will allow Stackr to evolve over time without major rewrites, simply by **extending** the system in new directions.

## Data Flow and Workflows

To understand how everything comes together, it’s useful to follow a typical **data flow** through Stackr – from initial user configuration to a completed buy and withdrawal cycle:

1. **User Setup:** The user installs Stackr and accesses the UI. They input configuration such as: schedule (e.g. daily at 9am), purchase amount (or bank account details if needed for funding – though often it’s assumed the exchange account has funds), exchange API keys, their wallet xpub for withdrawals, and strategy selection (could just be “basic DCA” initially). This config is saved in the SQLite database. The system now has what it needs to operate autonomously.
2. **Scheduler Triggers DCA:** At the scheduled time (say 9am daily), the scheduler (could be an internal timer or an external cron job triggering an API call to Stackr) activates the DCA Engine via the orchestrator. The LangGraph workflow for “execute scheduled buy” starts. The state carries the config (like amount \$100).
3. **Strategy Determines Buy Parameters:** The orchestrator calls into the Strategy Engine node. If it’s basic DCA, the strategy might just confirm the amount to buy is \$100 worth of BTC at market price. A more advanced strategy might adjust the amount or even decide to skip if conditions aren’t favorable. In our simple case, strategy returns an order: “Buy \$100 now.”
4. **Execute Buy Order:** The next node in the workflow invokes the Exchange Adapter to place the order. For example, it calls `adapter.buy(100 USD)` (Stackr might convert that to a quantity based on current price or use a market order for \$100 worth). The adapter makes the actual API call to the exchange (e.g., a POST to `/api/order` endpoint with the appropriate auth and params). The exchange executes the trade and returns a result (order filled, you bought 0.00025 BTC at \$40k/BTC, for instance). The adapter returns this info to the DCA Engine.
5. **Record and Notify Buy:** The workflow logs the purchase in the DB (as a new row in `purchases`). It then moves to a notification node that sends a push notification like “✅ Bought 0.00025 BTC for \$100 at \$40k/BTC”. The user receives this on their phone, giving them near-real-time feedback that the scheduled buy happened.
6. **Evaluate Withdrawal Condition:** After the buy, the orchestrator triggers the Withdrawal Module logic. According to the user’s withdrawal policy, it checks if it’s time to withdraw. Maybe the rule is “withdraw every 0.01 BTC or every month, whichever comes first.” Suppose after this buy, the user’s exchange balance is now 0.005 BTC, which is below 0.01 and it’s not month-end yet. The condition is not met, so the workflow would _skip_ the withdrawal steps. It might schedule the next check or just end. In this case, it goes to an end state with no withdrawal.
7. **(Later) Withdrawal Trigger:** After a few more days of DCA, the balance crosses 0.01 BTC. When the orchestrator runs the post-buy check this time, it finds the condition met (balance >= threshold, or maybe the calendar date hits the monthly withdrawal). Now the withdrawal process kicks in.
8. **Address Generation:** The Withdrawal Module’s first step is to get a new address from the xpub. It calls the `AddressProvider` which either calculates `index+n` or asks Bitcoin Core for a new address. Suppose it gets `tb1qXYZ...` (a testnet bech32 address) as the next destination.
9. **Initiate Withdrawal:** The module now calls the Exchange Adapter’s withdraw function: `adapter.withdraw(address, amount)`. This hits the exchange API to request a withdrawal of (say) 0.01 BTC to `tb1qXYZ...`. The exchange responds, typically with a transaction ID or a withdrawal request ID.
10. **Confirmation Steps:** The orchestrator will then log this withdrawal in the DB and send a notification: “🚚 Withdrew 0.01 BTC to your wallet (address ending ...XYZ). Awaiting confirmation.” The user sees this and knows to expect funds soon.
11. **Blockchain Confirmation:** The Bitcoin Core node, which is syncing testnet, will eventually see the transaction (since the address belongs to the user’s watch-only wallet or can be tracked). Once it gets a confirmation (block inclusion), Stackr can detect it (either via polling the RPC `gettransaction` or via a webhook-like mechanism if implemented). When confirmed, another notification can be sent: “✅ Withdrawal of 0.01 BTC confirmed on-chain in block ######.”
12. **Cycle Repeats:** The workflow ends. The orchestrator will await the next schedule tick to start over with the DCA step. Meanwhile, the user’s exchange balance might be reset to 0 (if they withdrew everything) or whatever remained. The user’s wallet (through the xpub) has now one more address used. The internal address index increments by 1, ensuring next time a new address will be used.
13. **User Interaction:** At any point, the user can check the app to see a summary (maybe it shows “Next buy: tomorrow 9am, Next withdrawal: in \~20 days or at 0.01 BTC”). If the user decides to change something (say they want to up the DCA amount or switch to a different strategy), they update the config in the app. This writes to SQLite and the changes will take effect on the next cycle (or immediately depending on what it is). Because of the clean separation, changing strategy just means the next time `getNextPurchase()` is called, it’s a different implementation.
14. **Edge Cases:** If something goes wrong at any step, the system either handles it or stops gracefully:

    - If the exchange API is unreachable during a scheduled buy, the orchestrator could catch that and notify the user (“⚠️ Buy at 9am failed due to network issue. Will retry at 10am.”). It might then schedule a retry node.
    - If the exchange rejects the withdrawal (maybe for KYC reasons or low balance), the error is logged and user notified (“⚠️ Withdrawal failed: ...”). The system might try again later or require user intervention depending on the error.
    - If Bitcoin Core is not running or syncing slow, that mostly affects address derivation and confirmation. The app would still perform buys and withdrawals; it just might not be able to verify them. In such cases, Stackr could either warn the user (“Bitcoin node not available, cannot verify addresses/transactions”) or operate in a degraded mode (trusting the exchange’s response until the node catches up).

![Data Flow Diagram: Sequence of a DCA and withdrawal process](data:image/png;base64,{{b64_images['stackr_dataflow.png']}})

_Figure: Data flow through a full cycle._ The diagram illustrates how data and actions move through Stackr: user configurations feed into the schedule and strategy, which triggers buys via an exchange adapter, results get logged and possibly initiate a withdrawal, which involves deriving a new address and calling the exchange’s withdraw API, finally notifying the user and updating records. External entities like the exchange and the Bitcoin network (via the Bitcoin Core node) interact at key points (buy execution, broadcasting the withdrawal transaction, etc.). This end-to-end flow shows Stackr’s components working in concert to automate the DCA and withdrawal process while keeping the user informed.

Through this workflow, we see that Stackr acts as a **glue** between the user, the exchange, and the Bitcoin network – automating the routine parts but always with the ability to inform or get input from the user. Data flows from the user’s intentions (config) to actions (buys, withdrawals) to outcomes (Bitcoin in the user’s wallet), closing the loop with logs and notifications.

## Conclusion

The Stackr application is **comprehensively designed** to fulfill its mission of automated Bitcoin accumulation (DCA) and secure self-custody withdrawals. Its architecture carefully balances automation with human oversight, leveraging modern frameworks and best practices:

- A clear separation of concerns is maintained among its core components (buy engine, strategy logic, withdrawal module), which interact through well-defined interfaces.
- Use of patterns like Strategy and Adapter ensure the system is extensible – new strategies or integrations can be added with minimal effort, and the system is adaptable to changing future requirements.
- LangGraph orchestration imbues the system with a high-level clarity in workflow management, making complex sequences and decision logic easier to implement and maintain. It also opens avenues for future AI integration for smart decision-making or natural language user commands.
- The inclusion of a Bitcoin Core node underscores a commitment to trustlessness and self-sovereignty, aligning with the ethos of Bitcoin by verifying on-chain activity independently and improving privacy (no reliance on third-party lookups).
- Dockerized deployment from the outset makes Stackr accessible to a wide range of users and contributors – running the app is as easy as running a couple of containers, and the environment is consistent across development, testing, and production.
- The focus on a mobile-friendly, notification-rich user experience ensures that while Stackr runs mostly unattended, the user is never out of the loop. This fosters trust in the system’s actions and provides peace of mind, as the user remains informed and can intervene if needed.
- Each design choice, from the use of SQLite to the push notification integration, has been made to maximize simplicity, security, and user control.

Stackr’s architecture is not only up-to-date with current technology (as of 2025) but is built with an eye towards the future. It can incorporate emerging best practices or tools (be it new exchange APIs, scaling solutions, or AI assistants) without fundamental redesign. This document has outlined the blueprint of Stackr’s system – a blueprint focused on **automation with accountability**. By adhering to these design principles and components, Stackr aims to become a reliable personal tool for Bitcoin accumulation, one that can be trusted to run 24/7, executing the user’s plan faithfully while the user retains ultimate control.
